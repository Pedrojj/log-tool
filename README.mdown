# log-tool

`log-tool` is a utility that can read, parse, and write data from log files and similar data sources.  It has a simple modular architecture, consisting of "input modules" to read the data, "parser modules" to format the data as needed, and "output modules" that send this data to some destination.  Each of these modules is stream based, and the configuration of these modules and the connections between them is specified in several simple configuration files.  This project includes several modules of each of these types, and the modular architecture is intended to make it easy to develop additional modules as needed.  All modules are mutually-compatible, and all of them receive their configuration options in the same way (described below.)

![Logtool](arch.png "Overview of Logtool architecture")

## Usage Summary

`npm start` to start the service (with the settings specified in the config files)
`npm stop` to stop the service
`npm restart` to restart the service
`npm test` to run the tests.

## Configuration Files

All of the following are json files located in the `config` directory.

### Application Configuration

The file `config.json` handles any configuration options for the application overall, such as how verbose its logging should be.

The default is to use the `development` environment, so in production, simply change the `environment` setting at the top of the file:

    "environment": "production"

Configuration options in `development` are inherited by `production`, but you can override them in the `production` block.

### Input Configuration

The file `input.json` specifies all needed information for each source of data.

In general, this config file names specific instances using their specified modules, and then pass the remaining values to that module for its constructor to handle.  Each instance name acts as a key for getting its configuration object.  A simple example may contain:

    {
      "source1":{
        "module":"file",
        "fileName":"test/data/some_file",
        "encoding":"utf-8"
      },
      "source2":{
        "module":"file-watch",
        "fileName":"in.txt",
        "timeout": 15000,
        "interval": 100,
        "encoding":"utf-8"
      }
    }

"source1" and "source2" are the names of these sources, "file" and "file-watch" are the modules these sources will use, and the remaining options will be passed to these instances of these modules.  In this example, the "file" module will be past a relative path and an encoding, while "file-watch" will be passed a relative path, an encoding, an interval to check for changes to this file, and a timeout value for when to stop watching this file.

### Output Configuration

The file `output.json` specifies all needed information for each destination of the data.

Like above, this config file names specific instances using their specified modules, and then pass the remaining values to that module for its constructor to handle.  Each instance name acts as a key for getting its configuration object.  A simple example may contain:

    {
      "dest1":{
        "module":"file",
        "fileName":"ids.out.txt"
      },
      "dest2": {
        "module"        : "redis-pubsub",
        "serverAddress" : "127.0.0.1",
        "serverPort"    : 6379,
        "channel"       : "events.nessus"
      }
    }

"dest1" and "dest2" are the names of these destinations, "file" and "redis-pubsub" are the modules these will use, and the remaining options will be passed to these instances of these modules.  In this example, the "file" module only needs to be passed a path, while the "redis-pubsub" module will be passed an address, a port, and the channel to use for sending its messages.

As another example:

    "nessus-store": {
      "module"        : "redis",
      "serverAddress" : "127.0.0.1",
      "serverPort"    : 6379,
      "keyPrefix"     : "logtool:events:nessus",
      "index"         : true,
      "indexedFields" : ["ip", "port", "vulnid"]
    }

This instance is named "nessus-store", uses the "redis" module, and passes it similar values as above, except instead of needing a channel name, it needs information about how to name its keys and which fields to include in its index.

### Parser Configuration

The file `parsers.json` specifies all needed information for each parser.

Like above, this config file names specific instances using their specified modules, and then pass the remaining values to that module for its constructor to handle.  Each instance name acts as a key for getting its configuration object.  An example may contain:

    {
      "null":{
        "module":"null"
      },
      "nessus":{
        "module":"nessus"
      },
      "firewall":{
        "module":"regex"
      , "regex": "^([^,]*),([^,]*),([^,]+),([^,]+),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*)"
      , "labels": ["timestamp", "priority", "operation", "messageCode", 
                    "protocol", "sourceIP", "destIP", "sourceHostname", "destHostname", "sourcePort", 
                    "destPort", "destService", "direction", "connectionsBuilt", "connectionsTornDown"
                  ]
      , "fields": { "timestamp": {"regex": "DD/MMM/YYYY HH:mm:ss", "type": "moment"} }
      , "delimiter": "\r\n|\n"
      , "startTime":0
      }
    }

"null", "nessus", and "firewall" are again the names of these parsers, and "null", "nessus", and "regex" are the modules these sources will use. The "null" and "nessus" modules do not require any additional options, while the "regex" module requires many additional options due to its more generic purpose.

### Connection Configuration

The file `connections.json` is somewhat different from the other configuration files.  This simply contains a list of connections to make between the names in the other config files.  For example:

    [
      {
        "input":"source1",
        "parser":"null",
        "output":"dest1"
      },
      {
        "input":"nessus-file",
        "parser":"nessus",
        "output":"nessus-store"
      }
    ]

The first entry will connect `input` to the parser named `null` to the output `dest1` -- this example will simply copy the file unmodified.

The second entry will connect `nessus-file` to the parser `nessus` to the output `nessus-store` -- this example will read and parse the specified nessus file, and store each entry in redis.

## Project Organization

logtool.js - launches the main logtool process.

input, output, and parsers directories - contain the modules of each type

config directory - contains configuration files, as described above

test directory - contains all test scripts and data.  Tests for each module are included in `test/module_type/module_name.test.js`

webserver directory - contains the webapp demo, described below.

lib directory - contains all core libraries for logtool (ie. everything except for the modules described above)

## Testing

All tests can be run with `npm test`  This will run jshint and the mocha tests.

Any module can be tested individually with mocha by passing the location of its tests, such as `mocha -u tdd -R spec ./test/parsers/regex.test.js`

Note that when testing, the main logtool process and all modules take their options directly from an `opts` argument, and do not read or modify the log files above.

## Webapp Demo

This project also includes a simple webapp, to demonstrate the use of these various components. 

To launch this demo:

1. launch redis with `redis-server` (and `flushall` if needed)
2. from the webserver directory: `node server.js`
3. visit `localhost:8000` in any modern browser
4. run logtool (note: if you change the channel names in output.json, you will then also need to modify which channels the webapp demo listens on)

For more information, see ./webserver/README.md

